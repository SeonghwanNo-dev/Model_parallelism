🛠️ 시스템 소프트웨어 핵심 시스템 호출 50선
I. 파일 및 I/O 관리 (File and I/O Management) - 10개
이 함수들은 데이터를 저장하거나 장치(디스크, 터미널 등)와 상호작용하는 기본입니다.

# 4 Fundamental calls
- open()
open a file, optionally creating it if needed
Returns file descriptor used by remaining calls
- read()
- write()
- close()


open(): 파일 또는 장치를 열어 파일 디스크립터를 얻습니다.
- 파일 디스크립터(FD, File Descriptor): 시스템 소프트웨어 엔지니어링 관점에서 가장 중요하게 다뤄지는 디스크립터
FD는 0 이상의 작은 정수 값
용도: 프로세스가 열린 파일, 소켓, 파이프, 또는 디바이스 등의 I/O 자원을 참조할 때 사용합니다.
작동 원리: 프로세스가 open() 시스템 호출을 사용하여 파일을 열면, 커널은 해당 파일에 대한 정보를 담는 구조체(File Structure)를 만들고, 이 구조체를 가리키는 **파일 디스크립터(정수)**를 사용자 프로세스에게 반환합니다.

read(): 파일 디스크립터에서 데이터를 읽습니다.
write(): 파일 디스크립터에 데이터를 씁니다.
- read()와 write()가 호출되면 그 명령은 프로세스가 아닌 커널에게 전달
- 커널은 이 명령을 받아 디스크립터와 연결된 장치 드라이버를 통해 하드웨어(디스크, 네트워크 카드 등)에 실제 작업을 수행하게 합니다.

close(): 파일 디스크립터를 닫습니다.

lseek(): 파일 포인터를 이동시킵니다.

stat() / fstat(): 파일의 상태(크기, 권한 등) 정보를 얻습니다.

ioctl(): 장치 파일(Device File)의 특수 기능을 제어합니다. (예: 터미널, 드라이버)
- ioctl은 일반적인 I/O를 넘어선 저수준의 하드웨어 제어가 필요할 때 사용되는 '만능 도구(Catch-all Interface)'입니다.


dup() / dup2(): 파일 디스크립터를 복제합니다. (리다이렉션에 사용)

fsync(): 버퍼의 내용을 디스크에 즉시 동기화합니다.

pipe(): 프로세스 간 통신을 위한 파이프를 생성합니다.

II. 프로세스 제어 및 관리 (Process Control and Management) - 10개
시스템 SW에서 가장 중요한 **동시성(Concurrency)**과 멀티프로세싱의 기초입니다.

fork(): 호출한 프로세스의 복사본(자식 프로세스)을 생성합니다.

execve(): 현재 프로세스를 새로운 프로그램으로 덮어씁니다.

wait() / waitpid(): 자식 프로세스가 종료될 때까지 기다립니다.

exit(): 프로세스를 종료하고 상태를 반환합니다.

getpid() / getppid(): 현재 프로세스 ID와 부모 프로세스 ID를 얻습니다.

kill(): 프로세스에 시그널(Signal)을 보냅니다.

sigaction(): 시그널 핸들러를 등록하거나 변경합니다.

sched_yield(): 현재 CPU 사용권을 포기하고 다른 프로세스에게 양보합니다. (스케줄링 관련)

nice(): 프로세스의 우선순위를 조정합니다.

setuid() / getuid(): 프로세스의 사용자 ID를 설정/획득합니다. (권한 관리)

III. 메모리 관리 (Memory Management) - 7개
malloc이 내부적으로 사용하는 함수와 가상 메모리 관리의 핵심입니다.

brk() / sbrk(): 프로그램의 데이터 영역(Heap) 크기를 조정합니다.

mmap(): 파일을 메모리 영역에 매핑하거나, 익명 영역을 생성합니다. (대용량 데이터, IPC에 중요)

munmap(): mmap()으로 매핑된 영역을 해제합니다.

mprotect(): 매핑된 메모리 영역의 접근 권한(읽기/쓰기/실행)을 변경합니다.

shmget() / shmat(): 공유 메모리를 생성하고 접근합니다. (IPC)

mlock(): 메모리 페이지가 스왑 아웃(Swap-out)되지 않도록 잠급니다. (고성능 시스템에 중요)

mincore(): 특정 메모리 페이지가 실제 물리 메모리에 존재하는지 확인합니다.

IV. 네트워크 및 I/O 멀티플렉싱 (Networking and I/O Multiplexing) - 10개
분산 시스템과 고성능 서버 개발의 핵심입니다.

socket(): 통신을 위한 소켓을 생성합니다.

bind(): 소켓에 주소(IP, Port)를 할당합니다.

listen(): 소켓을 연결 대기 상태로 만듭니다. (서버)

connect(): 원격 호스트에 연결을 시도합니다. (클라이언트)

accept(): 클라이언트의 연결 요청을 수락합니다.

send() / recv(): 소켓을 통해 데이터를 송수신합니다.

setsockopt(): 소켓의 옵션(예: 재사용, 버퍼 크기)을 설정합니다.

select() / poll(): 여러 파일 디스크립터의 I/O 상태 변화를 감시합니다.

epoll_create() / epoll_ctl() / epoll_wait(): 리눅스 고유의 고성능 비동기 I/O 감시 시스템입니다. (대규모 서버 개발의 핵심)

V. 타이밍 및 시간 관리 (Timing and Time Management) - 5개
시스템 동작의 정확성과 성능 측정에 사용됩니다.

time() / gettimeofday(): 현재 시각을 얻습니다.

clock_gettime(): 고해상도 시간을 얻습니다. (성능 측정/벤치마킹에 필수)

sleep() / usleep(): 프로세스를 일정 시간 동안 지연시킵니다.

nanosleep(): 나노초 단위의 정밀한 지연을 수행합니다.

timer_create(): 시스템 타이머를 생성합니다.

VI. 커널 및 시스템 정보 (Kernel and System Information) - 5개
시스템 환경 정보를 얻거나 설정하는 데 사용됩니다.

uname(): 운영체제 이름, 버전 등의 정보를 얻습니다.

sysctl(): 커널의 파라미터를 동적으로 읽거나 설정합니다.

mount() / umount(): 파일 시스템을 마운트/언마운트합니다.

getrlimit(): 프로세스의 자원 제한(파일 개수, 메모리 크기 등) 정보를 얻습니다.

reboot(): 시스템을 재부팅하거나 종료합니다.

VII. IPC 및 동기화 (Inter-Process Communication and Sync) - 3개
멀티프로세스 환경에서 자원을 공유하고 통신하는 데 사용됩니다.

semget() / semop(): 세마포어를 이용한 프로세스 동기화.

msgget() / msgsnd() / msgrcv(): 메시지 큐를 이용한 프로세스 통신.

flock(): 파일 전체에 대해 잠금을 설정/해제합니다.

이 49개(47~49는 묶음으로 50개로 간주)의 시스템 호출을 **'무엇을 하는지'**와 **'왜 이 함수를 써야 하는지'**를 중심으로 이해하시면, 시스템 소프트웨어의 핵심 원리를 완벽하게 파악할 수 있을 것입니다.
